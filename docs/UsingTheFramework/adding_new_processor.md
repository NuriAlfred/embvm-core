# Adding a New Processor

CLEAR-ALL_TODOs


# Processor implementations require items (such as include paths) which should not be leaked into
# other layers. Build the processor as a static library. Create a dependency which includes
# safe include paths and links against the library. The hardware platform will reference the dep.


This document describes the process for adding support for a new processor. 

The full guide assumes that you are adding a completely new module in the style of the [Nordic](https://github.com/embvm/nordic) or [STM32L4](https://github.com/embvm/stm32l4) processor modules.

If you're only going to be adding a new processor or variant to an existing module, please skip steps [TODO: list the steps].

A note regarding the processor_includes header: put into an internal/ directory

this is an idea for an update: this rquires us to expose internal headers in a way that makes it look public. We don't really want someone to include `<stm32l45/processor_includes.hpp>`... it's just for the internal processor architecture module. So that shouldn't be in the top-level folder. Adjust in other implementations, and make sure this is clear in the guide.

PJ: ADD DOCUMENTATION TO THE DEPENDENCY, BECAUSE I DIDN'T KNOW THIS AUTOMATICALLY. NEED AN INTEGRATION GUIDE FOR USING THAT MODULE!!!
(ARM, that is)


Before we switch tasks, I can implement another required header: `processor_architecture.hpp`.

PJ: NEED TO DOCUMENT WHAT TO DO HERE IN THE ARCH FOLDER - PROPER USE NOT SHOWN

```
#ifndef STM32L4R5_PROCESSOR_ARCH_DEF_HPP_
#define STM32L4R5_PROCESSOR_ARCH_DEF_HPP_

#include <arm_cortex_m.hpp>

using ProcessorArch = ARMCortexMArch;

#endif // STM32L4R5_PROCESSOR_ARCH_DEF_HPP_
```

### A Note on Implementing the Override Behavior

PJ: revisit this... it technically doesn't work from a master project!
But it would with cross files - you need to set the variable appropriately?
Or not? 
this doesn't work because we're going to be a subproject, so variables isn't good enough. We need an option to be set. Let's deal with that later.

PJ: I also want to do the same for the linker script, now that I'm thinking about it. We can provide a default for the processor, and the user can override it if necessary at the platform level. What do you think of that? Well - I guess what I really think is that we should have a common logic section at the processor level (with an option to override), and then the platform level declares the memory regions (flash/ram) and can add extras.

We define a variable that holds a list of default files used for the processor implementation. Then we can check for the presence of an optional variable - if it's set, we'll use the user's files. If not, we'll use our default file list.

```
stm32l4r5_processor_default_files = files(
    'internal/stm32l4xx_it.c',
    'internal/system_stm32l4xx.c',
    'internal/startup_stm32l4r5xx.s',
)

stm32l4r5_processor_files = get_variable('stm32l4r5_processor_files', stm32l4r5_processor_default_files)
```

Then we update the library to reference the parsed variable:

```
stm32l4r5 = static_library('stm32l4r5',
    sources: [
        files('stm32l4r5.cpp'),
        stm32l4r5_processor_files, # New Line
    ],
    # ...
)
```


### Processor Bring-up

We know we're going to need more files for our program on the processor side:

```
stm32l4xx_it.c \
stm32l4xx_hal_msp.c \
system_stm32l4xx.c
startup_stm32l4r5xx.s
```

These files are typically tuned per-system and are generated by CubeMX. Templates are provided inside of the STM32CubeL4 repository that we can use. We'll tweak some aspects for the Embedded VM and provide defaults. We'll also need a way for users to override the settings (eventually).

We can find template files in the STM32CubeL4 projects here: `STM32CubeL4/Projects/NUCLEO-L4R5ZI/Templates`. These have example source files in `Src/`, as well as startup code and the linker script in the `SW4STM32` folder. There's a header we need in `Inc/`: `stm32l4xx_it.h`. We will copy these files into the `src/processor/STM32L4R5` folder, and put them in a subdirectory called `internal/`.

```
    stm32l4xx_it.c
    system_stm32l4xx.c
    startup_stm32l4r5xx.s
    stm32l4xx_it.h
```

Note that the `stm32l4xx_hal_msp.c` file is for STM32 HAL overrides for weak functions; these files are blank in the templates and we can override any HAL functions in our processor source files instead. Looking at the `Template` vs `Template_LL` directories, `system_stym32l4xx.c` and `startup_stm32l4r5xx.s` are the same. It doesn't matter which we pick.

We should also copy the linker script for now: `STM32L4R5ZITx_FLASH.ld`, but we're going to handle tuning this file at a later point.

### Architecture Integration

Before we switch tasks, I can implement another required header: `processor_architecture.hpp`.

```
#ifndef STM32L4R5_PROCESSOR_ARCH_DEF_HPP_
#define STM32L4R5_PROCESSOR_ARCH_DEF_HPP_

#include <arm_cortex_m.hpp>

using ProcessorArch = ARMCortexMArch;

#endif // STM32L4R5_PROCESSOR_ARCH_DEF_HPP_
```

Now we can hook up the `reset_()` function in `stm32l4r5.cpp`

```
#include "stm32l4r5.hpp"
#include <processor_architecture.hpp>
#include <processor_includes.hpp>

#pragma mark - Definitions -

#pragma mark - Helpers -

#pragma mark - Interface Functions -

stm32l4r5::~stm32l4r5() {}

void stm32l4r5::earlyInitHook_() noexcept {}

void stm32l4r5::init_() noexcept {}

void stm32l4r5::reset_() noexcept
{
    ProcessorArch::systemReset();
}
```

## Linker Script

Now, the ARM architecture has a common linker script that can be used for ARM projects: `gcc_arm_common.ld`.

Looking at the STM32 linker script and the common linker script, I don't see anything that is necessary in their version of the file. Everything is pretty standard. Entry points are the same too.

We just need to note these values for our processor:

```
/* Highest address of the user mode stack */
_estack = 0x200A0000;    /* end of RAM */ ----- this i s used by the STM32 startup files! (does nordic also have it

/* Specify the memory areas */
MEMORY
{
RAM (xrw)      : ORIGIN = 0x20000000, LENGTH = 640K
FLASH (rx)      : ORIGIN = 0x8000000, LENGTH = 2048K
}
```

We can delete `STM32L4R5ZITx_FLASH.ld` from our project. In the `platform/nucleo_l4r5zi_demo` folder, we'll create the missing `blinky_gcc_nucleo_l4rzi.ld` file. We'll past our saved memory values above, and then include the common linker script.

```
/* Linker script to configure memory regions. */

/* Highest address of the user mode stack */
_estack = 0x200A0000;    /* end of RAM */ ----- this i s used by the STM32 startup files! (does nordic also have it

/* Specify the memory areas */
MEMORY
{
RAM (xrw)      : ORIGIN = 0x20000000, LENGTH = 640K
FLASH (rx)      : ORIGIN = 0x8000000, LENGTH = 2048K
}

INCLUDE "gcc_arm_common.ld"
```

Now we can run our build, and we get new failures!

```
(.text.Reset_Handler+0x3c): undefined reference to `_sidata'
/usr/local/toolchains/gcc-arm-none-eabi/bin/../lib/gcc/arm-none-eabi/9.2.1/../../../../arm-none-eabi/bin/ld: (.text.Reset_Handler+0x40): undefined reference to `_sdata'
/usr/local/toolchains/gcc-arm-none-eabi/bin/../lib/gcc/arm-none-eabi/9.2.1/../../../../arm-none-eabi/bin/ld: (.text.Reset_Handler+0x44): undefined reference to `_edata'
/usr/local/toolchains/gcc-arm-none-eabi/bin/../lib/gcc/arm-none-eabi/9.2.1/../../../../arm-none-eabi/bin/ld: (.text.Reset_Handler+0x48): undefined reference to `_sbss'
/usr/local/toolchains/gcc-arm-none-eabi/bin/../lib/gcc/arm-none-eabi/9.2.1/../../../../arm-none-eabi/bin/ld: (.text.Reset_Handler+0x4c): undefined reference to `_ebss'
```

### Updating Initialization Code

These missing symbols are used by the initialization code and were previously defined by the STM32 linker script.

Our common linker script already defines these values, which have a different name but serve the same purpose:

```
 *   __StackLimit
 *   __StackTop
 *   __stack
 *   __data_start__
 *  etc...
```

For example, We can change the initialization code to refer to __StackLimit instead of _estack.

## Tuning the Startup File

This is actually the hard part of integrating a new processor. That's because there's no easy solution. You have to look at the assembly and make sure it's doing things correctly.

The primary objective is to perform any a) basic initialization that is required before b) kicking off the libc initialization process (in `crt0.S` defined by the architecture), which will perform stuff like setting up stacks and clearing BSS, and then it will run the framework boot strategy defined by the platform.

So for the STM32 startup file, the first thing we need to do is replace the `bl main` with `bl _start`, ensuring we jump to the proper `libc` entry point.

```
/* Call the libc entry point.*/
    bl    _start
```

Now, let's just work backwards. the following code above the `bl _start` call is equivalent to what's happening in `libc`, so we can just remove it:

```
/* Zero fill the bss segment. */
FillZerobss:
    movs    r3, #0
    str    r3, [r2], #4

LoopFillZerobss:
    ldr    r3, = _ebss
    cmp    r2, r3
    bcc    FillZerobss

/* Call static constructors */
    bl __libc_init_array
```

Next we need to adjust the "data copy loop" to use our common linker script symbols instead of the STM32 ones. We'll use this form intead of the STM32 approach:

```
/* Loop to copy data from read only memory to RAM.
 * The ranges of copy from/to are specified by following symbols:
 *      __etext: LMA of start of the section to copy from. Usually end of text
 *      __data_start__: VMA of start of the section to copy to.
 *      __bss_start__: VMA of end of the section to copy to. Normally __data_end__ is used, but by using __bss_start__
 *                    the user can add their own initialized data section before BSS section with the INSERT AFTER command.
 *
 * All addresses must be aligned to 4 bytes boundary.
 */
#ifndef __STARTUP_SKIP_ETEXT
    ldr r1, =__etext
    ldr r2, =__data_start__
    ldr r3, =__bss_start__

    subs r3, r3, r2
    ble .L_loop1_done

.L_loop1:
    subs r3, r3, #4
    ldr r0, [r1,r3]
    str r0, [r2,r3]
    bgt .L_loop1

.L_loop1_done:
#endif
```

The symbols used above come from our linker script. We can delete these:

```
/* start address for the initialization values of the .data section.
defined in linker script */
.word    _sidata
/* start address for the .data section. defined in linker script */
.word    _sdata
/* end address for the .data section. defined in linker script */
.word    _edata
/* start address for the .bss section. defined in linker script */
.word    _sbss
/* end address for the .bss section. defined in linker script */
.word    _ebss
```

Finally, we'll change this value: 

```
ldr   sp, =_estack    /* Set stack pointer */
```

to 

```
ldr sp, =__StackTop
```

and then change 

```
.word _estack
```

to 

```
.word __StackTop
```

## New Processor Bring-up Checklist

1. [ ] Create a repository using the [Embedded VM Project Skeleton](https://github.com/embvm/embvm-project-skeleton) template.
1. [ ] Import Processor Vendor SDK, if desired
    1. [ ] Create a wrap file


## New Processor Bring-up Guide

### Initial Repository Setup

- Create a repository using the [Embedded VM Project Skeleton](https://github.com/embvm/embvm-project-skeleton) template



## Parse this
some of this can go here
some can go into the driver version

### GPIO Driver Implementation

> **Note:** The GPIO base class was redesigned after this development log was written, so the exact implementation notes are slightly outdated. However, the process is still valid.

We'll start by including our basic GPIO class:

```
#include <driver/gpio.hpp>
```

I'll also describe a basic GPIO output class that takes a templated port/pin. Because we don't want to leak implementation details, I'm going to forward these calls to translation class that handles the implementation details under the hood.

```
template<uint8_t TPort, uint8_t TPin>
class STM32GPIOOutput final : public embvm::gpio::output
{
  public:
    /** Construct a generic GPIO output
     */
    explicit STM32GPIOOutput() noexcept : embvm::gpio::output("nRF GPIO Output") {}

    /** Construct a named GPIO output
     *
     * @param name The name of the GPIO pin
     */
    explicit STM32GPIOOutput(const char* name) noexcept : embvm::gpio::output(name) {}

    /// Default destructor
    ~STM32GPIOOutput() final = default;

    void set(bool v) noexcept final
    {
        if(v)
        {
            STM32GPIOTranslator::set(TPort, TPin);
        }
        else
        {
            STM32GPIOTranslator::clear(TPort, TPin);
        }
    }

  private:
    void start_() noexcept final
    {
        STM32GPIOTranslator::configure_output(TPort, TPin);
    }

    void stop_() noexcept final
    {
        STM32GPIOTranslator::configure_default(TPort, TPin);
    }
};
```

We'll preemptively include this header:

```
#include "helpers/gpio_helper.hpp"
```

Now to make `gpio_helper.hpp` and `gpio_helper.cpp` in `drivers/helpers`.

The header file is going to be a simple interface that defines static functions

```
#ifndef STM32_GPIO_HELPER_HPP_
#define STM32_GPIO_HELPER_HPP_

#include <cstdint>

/** Translation class which handles STM32 GPIO Configuration.
 *
 * This represents a bridge pattern: the implementation of the GPIO functions is separated from the
 * main interfaces (STM32GPIOOutput, STM32GPIOInput, etc.).
 *
 * The GPIO function implementations are isolated from this header because we do not want to make
 * the STM32 headers accessible from the rest of the system.
 *
 * This class cannot be directly instantiated.
 */
class STM32GPIOTranslator
{
  public:
    static void configure_output(uint8_t port, uint8_t pin) noexcept;
    static void configure_input(uint8_t port, uint8_t pin, uint8_t pull_config) noexcept;
    static void configure_default(uint8_t port, uint8_t pin) noexcept;
    static void set(uint8_t port, uint8_t pin) noexcept;
    static void clear(uint8_t port, uint8_t pin) noexcept;

  private:
    /// This class can't be instantiated
    STM32GPIOTranslator() = default;
    ~STM32GPIOTranslator() = default;
};

#endif // STM32_GPIO_HELPER_HPP_
```

The source file will be implementations of these functions.

We'll start with the includes:

```
#include "gpio_helper.h"
#include <processor_includes.hpp>
```

We also need to decide whether we want to use the HAL or LL drivers at this point. Eventually we can supply implementations for both, but we need to pick one fundamentally. For now, we're going to use the LL drivers.

In the `.cpp` file, we need to include `<stm32l4xx_ll_gpio.h>`.

Something comes to mind looking at the STM32 files. Predictably, there are multiple ports supported on this processor: `GPIOA...GPIOI`

Now, we don't want to parameterize our template classes by using pointers, and we don't want to expose any headers or implementation details on the STM32 side to the rest of the program. So what can we do? Declare an `enum` that is mapped to the values internally:

```
enum STM32GPIOPort : uint8_t {
    A = 0,
    B,
    C,
    D,
    E,
    F,
    G,
    H,
    I,
};
```

Then we change our template header:
`template<STM32GPIOPort TPort, uint8_t TPin>`

Inside of our` gpio_helper.cpp` file, we can define an array that can map these values to our actual pointer types:

```
constexpr std::array<GPIO_TypeDef*,9> ports = {GPIOA, GPIOB, GPIOC, GPIOD, GPIOE, GPIOF, GPIOG, GPIOH, GPIOI};
```

We also need to translate our integral pin number [0..15] into the proper STM32 representation, which is a bitmask.

```
#define PIN_INT_TO_STM32(x) (1 << x)
```

Now we can map our helper functions to the LL functions and types:

```
void STM32GPIOTranslator::configure_output(uint8_t port, uint8_t pin) noexcept
{
    LL_GPIO_InitTypeDef gpio_init = {
        .Pin = PIN_INT_TO_STM32(pin),
        .Mode = LL_GPIO_MODE_OUTPUT,
        .Speed = LL_GPIO_SPEED_FREQ_MEDIUM,
        .OutputType = LL_GPIO_OUTPUT_PUSHPULL,
        .Pull = LL_GPIO_PULL_NO,
        .Alternate = LL_GPIO_AF_0
    };

    LL_GPIO_Init([ports[port], &gpio_init); // GPIOx, GPIO_InitStruct
}

void STM32GPIOTranslator::configure_input(uint8_t port, uint8_t pin, uint8_t pull_config) noexcept
{
    LL_GPIO_InitTypeDef gpio_init = {
        .Pin = PIN_INT_TO_STM32(pin),
        .Mode = LL_GPIO_MODE_INPUT,
        .Speed = LL_GPIO_SPEED_FREQ_MEDIUM,
        .Pull = LL_GPIO_PULL_NO,
        .Alternate = LL_GPIO_AF_0,
    };

    LL_GPIO_Init(ports[port], &gpio_init); // GPIOx, GPIO_InitStruct
}

void STM32GPIOTranslator::configure_default(uint8_t port, uint8_t pin) noexcept
{
    configure_input(port, pin, 0); // TODO: set to no-pull
}

void STM32GPIOTranslator::set(uint8_t port, uint8_t pin) noexcept
{
    LL_GPIO_SetOutputPin(ports[port], PIN_INT_TO_STM32(pin)); // GPIOx, PinMask
}

void STM32GPIOTranslator::clear(uint8_t port, uint8_t pin) noexcept
{
    LL_GPIO_ResetOutputPin(ports[port], PIN_INT_TO_STM32(pin)); // GPIOx, PinMask
}
```

Next we need to get this into the build. In `src/drivers/meson.build`:

```
# src/drivers/meson.build

stm32_common_drivers_include = include_directories('.')

stm32_common_drivers_dep = declare_dependency(
    include_directories: stm32_common_drivers_include,
    sources: [
        'helpers/gpio_helper.cpp',
    ],
    dependencies: stm32_ll_dep,
)
```

We'll add the `subdir` call to the `src/meson.build` file. It needs to be included before processor so we can use the driver dependency in the processor build target.

```
subdir('drivers')
subdir('processor')
subdir('hw_platform')
subdir('platform')
subdir('app')
```

In our processor library target, we'll add the driver dependency to the library build and the include directory to the processor dependency:

```
stm32l4r5 = static_library('stm32l4r5',
    sources: [
        files('stm32l4r5.cpp'),
        stm32l4r5_processor_files,
    ],
    c_args: [
        '-DSTM32L4R5xx',
    ],
    cpp_args: [
        '-DSTM32L4R5xx',
    ],
    include_directories: [
        include_directories('internal'),
        cmsis_cortex_m_include,
    ],
    dependencies: [
        framework_include_dep,
        framework_host_include_dep,
        stm32_cmsis_device_dep,
        arm_dep,
        stm32_common_drivers_dep,
    ],
    build_by_default: meson.is_subproject() == false
)

stm32l4r5_processor_dep = declare_dependency(
    include_directories: [
        include_directories('.', is_system: true),
        stm32_common_drivers_include
    ],
    dependencies: [

    ],
    link_with: stm32l4r5,
)
```
