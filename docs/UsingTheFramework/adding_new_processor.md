# Adding a New Processor

CLEAR-ALL_TODOs


# Processor implementations require items (such as include paths) which should not be leaked into
# other layers. Build the processor as a static library. Create a dependency which includes
# safe include paths and links against the library. The hardware platform will reference the dep.


This document describes the process for adding support for a new processor. 

The full guide assumes that you are adding a completely new module in the style of the [Nordic](https://github.com/embvm/nordic) or [STM32L4](https://github.com/embvm/stm32l4) processor modules.

If you're only going to be adding a new processor or variant to an existing module, please skip steps [TODO: list the steps].

A note regarding the processor_includes header: put into an internal/ directory

this is an idea for an update: this rquires us to expose internal headers in a way that makes it look public. We don't really want someone to include `<stm32l45/processor_includes.hpp>`... it's just for the internal processor architecture module. So that shouldn't be in the top-level folder. Adjust in other implementations, and make sure this is clear in the guide.

PJ: ADD DOCUMENTATION TO THE DEPENDENCY, BECAUSE I DIDN'T KNOW THIS AUTOMATICALLY. NEED AN INTEGRATION GUIDE FOR USING THAT MODULE!!!
(ARM, that is)


Before we switch tasks, I can implement another required header: `processor_architecture.hpp`.

PJ: NEED TO DOCUMENT WHAT TO DO HERE IN THE ARCH FOLDER - PROPER USE NOT SHOWN

```
#ifndef STM32L4R5_PROCESSOR_ARCH_DEF_HPP_
#define STM32L4R5_PROCESSOR_ARCH_DEF_HPP_

#include <arm_cortex_m.hpp>

using ProcessorArch = ARMCortexMArch;

#endif // STM32L4R5_PROCESSOR_ARCH_DEF_HPP_
```

### A Note on Implementing the Override Behavior

PJ: revisit this... it technically doesn't work from a master project!
But it would with cross files - you need to set the variable appropriately?
Or not? 
this doesn't work because we're going to be a subproject, so variables isn't good enough. We need an option to be set. Let's deal with that later.

PJ: I also want to do the same for the linker script, now that I'm thinking about it. We can provide a default for the processor, and the user can override it if necessary at the platform level. What do you think of that? Well - I guess what I really think is that we should have a common logic section at the processor level (with an option to override), and then the platform level declares the memory regions (flash/ram) and can add extras.

We define a variable that holds a list of default files used for the processor implementation. Then we can check for the presence of an optional variable - if it's set, we'll use the user's files. If not, we'll use our default file list.

```
stm32l4r5_processor_default_files = files(
    'internal/stm32l4xx_it.c',
    'internal/system_stm32l4xx.c',
    'internal/startup_stm32l4r5xx.s',
)

stm32l4r5_processor_files = get_variable('stm32l4r5_processor_files', stm32l4r5_processor_default_files)
```

Then we update the library to reference the parsed variable:

```
stm32l4r5 = static_library('stm32l4r5',
    sources: [
        files('stm32l4r5.cpp'),
        stm32l4r5_processor_files, # New Line
    ],
    # ...
)
```


### Processor Bring-up

We know we're going to need more files for our program on the processor side:

```
stm32l4xx_it.c \
stm32l4xx_hal_msp.c \
system_stm32l4xx.c
startup_stm32l4r5xx.s
```

These files are typically tuned per-system and are generated by CubeMX. Templates are provided inside of the STM32CubeL4 repository that we can use. We'll tweak some aspects for the Embedded VM and provide defaults. We'll also need a way for users to override the settings (eventually).

We can find template files in the STM32CubeL4 projects here: `STM32CubeL4/Projects/NUCLEO-L4R5ZI/Templates`. These have example source files in `Src/`, as well as startup code and the linker script in the `SW4STM32` folder. There's a header we need in `Inc/`: `stm32l4xx_it.h`. We will copy these files into the `src/processor/STM32L4R5` folder, and put them in a subdirectory called `internal/`.

```
    stm32l4xx_it.c
    system_stm32l4xx.c
    startup_stm32l4r5xx.s
    stm32l4xx_it.h
```

Note that the `stm32l4xx_hal_msp.c` file is for STM32 HAL overrides for weak functions; these files are blank in the templates and we can override any HAL functions in our processor source files instead. Looking at the `Template` vs `Template_LL` directories, `system_stym32l4xx.c` and `startup_stm32l4r5xx.s` are the same. It doesn't matter which we pick.

We should also copy the linker script for now: `STM32L4R5ZITx_FLASH.ld`, but we're going to handle tuning this file at a later point.

### Architecture Integration

Before we switch tasks, I can implement another required header: `processor_architecture.hpp`.

```
#ifndef STM32L4R5_PROCESSOR_ARCH_DEF_HPP_
#define STM32L4R5_PROCESSOR_ARCH_DEF_HPP_

#include <arm_cortex_m.hpp>

using ProcessorArch = ARMCortexMArch;

#endif // STM32L4R5_PROCESSOR_ARCH_DEF_HPP_
```

Now we can hook up the `reset_()` function in `stm32l4r5.cpp`

```
#include "stm32l4r5.hpp"
#include <processor_architecture.hpp>
#include <processor_includes.hpp>

#pragma mark - Definitions -

#pragma mark - Helpers -

#pragma mark - Interface Functions -

stm32l4r5::~stm32l4r5() {}

void stm32l4r5::earlyInitHook_() noexcept {}

void stm32l4r5::init_() noexcept {}

void stm32l4r5::reset_() noexcept
{
    ProcessorArch::systemReset();
}
```

## Linker Script

Now, the ARM architecture has a common linker script that can be used for ARM projects: `gcc_arm_common.ld`.

Looking at the STM32 linker script and the common linker script, I don't see anything that is necessary in their version of the file. Everything is pretty standard. Entry points are the same too.

We just need to note these values for our processor:

```
/* Highest address of the user mode stack */
_estack = 0x200A0000;    /* end of RAM */ ----- this i s used by the STM32 startup files! (does nordic also have it

/* Specify the memory areas */
MEMORY
{
RAM (xrw)      : ORIGIN = 0x20000000, LENGTH = 640K
FLASH (rx)      : ORIGIN = 0x8000000, LENGTH = 2048K
}
```

We can delete `STM32L4R5ZITx_FLASH.ld` from our project. In the `platform/nucleo_l4r5zi_demo` folder, we'll create the missing `blinky_gcc_nucleo_l4rzi.ld` file. We'll past our saved memory values above, and then include the common linker script.

```
/* Linker script to configure memory regions. */

/* Highest address of the user mode stack */
_estack = 0x200A0000;    /* end of RAM */ ----- this i s used by the STM32 startup files! (does nordic also have it

/* Specify the memory areas */
MEMORY
{
RAM (xrw)      : ORIGIN = 0x20000000, LENGTH = 640K
FLASH (rx)      : ORIGIN = 0x8000000, LENGTH = 2048K
}

INCLUDE "gcc_arm_common.ld"
```

Now we can run our build, and we get new failures!

```
(.text.Reset_Handler+0x3c): undefined reference to `_sidata'
/usr/local/toolchains/gcc-arm-none-eabi/bin/../lib/gcc/arm-none-eabi/9.2.1/../../../../arm-none-eabi/bin/ld: (.text.Reset_Handler+0x40): undefined reference to `_sdata'
/usr/local/toolchains/gcc-arm-none-eabi/bin/../lib/gcc/arm-none-eabi/9.2.1/../../../../arm-none-eabi/bin/ld: (.text.Reset_Handler+0x44): undefined reference to `_edata'
/usr/local/toolchains/gcc-arm-none-eabi/bin/../lib/gcc/arm-none-eabi/9.2.1/../../../../arm-none-eabi/bin/ld: (.text.Reset_Handler+0x48): undefined reference to `_sbss'
/usr/local/toolchains/gcc-arm-none-eabi/bin/../lib/gcc/arm-none-eabi/9.2.1/../../../../arm-none-eabi/bin/ld: (.text.Reset_Handler+0x4c): undefined reference to `_ebss'
```

### Updating Initialization Code

These missing symbols are used by the initialization code and were previously defined by the STM32 linker script.

Our common linker script already defines these values, which have a different name but serve the same purpose:

```
 *   __StackLimit
 *   __StackTop
 *   __stack
 *   __data_start__
 *  etc...
```

For example, We can change the initialization code to refer to __StackLimit instead of _estack.

## Tuning the Startup File

This is actually the hard part of integrating a new processor. That's because there's no easy solution. You have to look at the assembly and make sure it's doing things correctly.

The primary objective is to perform any a) basic initialization that is required before b) kicking off the libc initialization process (in `crt0.S` defined by the architecture), which will perform stuff like setting up stacks and clearing BSS, and then it will run the framework boot strategy defined by the platform.

So for the STM32 startup file, the first thing we need to do is replace the `bl main` with `bl _start`, ensuring we jump to the proper `libc` entry point.

```
/* Call the libc entry point.*/
    bl    _start
```

Now, let's just work backwards. the following code above the `bl _start` call is equivalent to what's happening in `libc`, so we can just remove it:

```
/* Zero fill the bss segment. */
FillZerobss:
    movs    r3, #0
    str    r3, [r2], #4

LoopFillZerobss:
    ldr    r3, = _ebss
    cmp    r2, r3
    bcc    FillZerobss

/* Call static constructors */
    bl __libc_init_array
```

Next we need to adjust the "data copy loop" to use our common linker script symbols instead of the STM32 ones. We'll use this form intead of the STM32 approach:

```
/* Loop to copy data from read only memory to RAM.
 * The ranges of copy from/to are specified by following symbols:
 *      __etext: LMA of start of the section to copy from. Usually end of text
 *      __data_start__: VMA of start of the section to copy to.
 *      __bss_start__: VMA of end of the section to copy to. Normally __data_end__ is used, but by using __bss_start__
 *                    the user can add their own initialized data section before BSS section with the INSERT AFTER command.
 *
 * All addresses must be aligned to 4 bytes boundary.
 */
#ifndef __STARTUP_SKIP_ETEXT
    ldr r1, =__etext
    ldr r2, =__data_start__
    ldr r3, =__bss_start__

    subs r3, r3, r2
    ble .L_loop1_done

.L_loop1:
    subs r3, r3, #4
    ldr r0, [r1,r3]
    str r0, [r2,r3]
    bgt .L_loop1

.L_loop1_done:
#endif
```

The symbols used above come from our linker script. We can delete these:

```
/* start address for the initialization values of the .data section.
defined in linker script */
.word    _sidata
/* start address for the .data section. defined in linker script */
.word    _sdata
/* end address for the .data section. defined in linker script */
.word    _edata
/* start address for the .bss section. defined in linker script */
.word    _sbss
/* end address for the .bss section. defined in linker script */
.word    _ebss
```

Finally, we'll change this value: 

```
ldr   sp, =_estack    /* Set stack pointer */
```

to 

```
ldr sp, =__StackTop
```

and then change 

```
.word _estack
```

to 

```
.word __StackTop
```

## New Processor Bring-up Checklist

1. [ ] Create a repository using the [Embedded VM Project Skeleton](https://github.com/embvm/embvm-project-skeleton) template.
1. [ ] Import Processor Vendor SDK, if desired
    1. [ ] Create a wrap file


## New Processor Bring-up Guide

### Initial Repository Setup

- Create a repository using the [Embedded VM Project Skeleton](https://github.com/embvm/embvm-project-skeleton) template
- 
